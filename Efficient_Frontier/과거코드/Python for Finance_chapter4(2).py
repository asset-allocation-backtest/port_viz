# 새로 그냥 하나 만들었음.
# 여기 제목은 "코드 벡터화"임

# 코드 벡터화의 기본적인 아이디어는 복잡한 객체에 연산이나 함수를 적용할 때, 원소를 하나씩 반복하는 게 아니라
# 객체 그냥 전체를 한 방에 적용한다는 것.
# map, filter, reduce와 같은 매써드를 이용할 수도있고
# Numpy를 적용하면 더 깊은 부분까지 벡터화 할 수 있다고 함.


# 기본적인 벡터화
import numpy as np
r = np.random.standard_normal((4, 3))           # numpy라는 모듈에는 랜덤이란 매써드가 있고, 그 매써드에는 standard_normal매써드가 있나보다
print(r, 'r')
s = np.random.standard_normal((4, 3))           # 그리고 입력한 size에 맞게 4행 3열의 표준정규분포에서 꺼낸 난수들이 원소로 있네
print(s, 's')
print(r + s, 'r + s')
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------
# 근데 웃긴게 있어 이거 봐바
print(2*r + 3, '2*r + 3')                       # 이게 구동이 된단 말이지? 행렬에 2를 곱한건 그래 뭐 행렬에 상수 곱... 있다치자
                                                # 더하기 뭐냐? 3을 더하는게 말이되나??
                                                # 말이 안되지, 3을 더하는 건 사실 4x3인 행렬에 모든 요소가 3인 행렬을 더했다라는 건데
                                                # 이를 '브로드캐스팅'되었다라고 말을 함. 그렇게 알맞게 확장 시켜서 더해버리는 것이지
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------
t = np.random.standard_normal(3)
print(t, 't')                                   # 이렇게 만들면, 1행 3열짜리 행렬이 만들어 지는데
print(r, 'r')                                   # 다시 한번 r봐바, 이게 t랑 r 더해볼 거거든
print(r + t, 'r+t')                             # 1 x 3 행렬이 4 x 3과 더해지기 위해서, 4 x 3으로 브로드캐스팅 된다는 것!
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------
u = np.random.standard_normal(4)
print(u, 'u')                                   # 이건 1 x 4행렬을 만들었는데,
print(r, 'r')                                   # 1 x 4 행렬과 4 x 3 행렬은 과연 더해질까?
# print(u + r, 'u+r')                           # 안 더해짐... ValueError: operands couldn't be broadcast together with shapes(4,) (4, 3) 라고 뜸
# 굳이 이걸 해야겠다 싶으면, 4x3행렬을 3x4로 바꾸면
# 1x4 행렬이 3x4로 브로드캐스팅 되어서 연산이 될꺼잖아? ㅇㅋㅇㅋ transpose해본 다음에 더해보자
print(r.transpose() + u, 'r.transpose() + u')
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------
u2 = np.random.standard_normal((4,1))           # 그러면 예상대로라면, 4 x 1 행렬은
print(u2, 'u2')                                 # 4 x 3 행렬과 더해지기 위해서 4x1에서 4x3으로 자동으로 브로드캐스팅 되어서 더해져야 할텐데?
print(r, 'r')
print(u2 + r, 'u2 + r')                         # 오~~~ 진짜로 더해짐~ 욜
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------

# 함수에서 배열(array)을 마치 그냥 integer나 float처럼 다룬다????
# 브로드캐스트랑 일맥상통으로 이해할 수 있을 것 같은데, 수학적으론 말도 안되는(?)거를 할 수 있음
# 각 원소들을 그냥 쭉 함수에 넣어버리고, 나오는 함수값들을 함수로 뽑아내는 거!!!!
def f(x):
    return 3 * x + 5
print(f(0.4), 'f(0.4)')
print(f(r), 'f(r)')                             # 각 원소들을 함수에 숑!숑!숑! 넣어서 다시 원소로 받아서 가져오네?
                                                # 이런거를 수학에서 한 적이 있나? 암튼, 그렇다고! ㅎㅎ
                                                # 반복문을 사용하지 않고 이런걸 할 수 있다는 걸 알고 넘어가자는 게 골자!

# 근데 numpy.ndarray를 아무대나 그냥 막 꽂아넣을 수 있는건 아니야
# 예를 들어서 표준 라이브러리 math에 들어있는 sin()함수에는 numpy 배열을 넣을 수 없다고 함.

import math
print(math.sin(30), 'sin(30)')                  # 그냥 숫자는 들어가는데,
# print(math.sin(r))                            # 행렬은 안들어간다니까

                                                # 그래서 Numpy는 numpy내부적으로 ndarray가 들어가는 전형적인 함수에 대해서는 준비해놨다고 함
print(np.sin(r), 'np.sin(r)')                   # 돌아가는 거 보면 이해가 감.
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------

# numpy.zeros 명령으로 numpy.ndarray 객체를 생성할 때에는 메모리 배치에 대한 인수를 추가적으로 설정할 수 있다고 해.
# 난 이게 뭔 소린지 1도 모르겠는데, 일단 적어두고 가보자.

# 이게 이제 size가 큰 배열을 다룰 때에는 어떤 연산을 하느냐에 따라서 얘기가 많이 달라진다고 하니

x = np.random.standard_normal((5, 10000000))
print(type(x), 'x')                             # ㅇㅇㅇ 얘는 numpy.ndarray 객체가 맞아
y = 2 * x + 3
C = np.array((x, y), order='C')
F = np.array((x, y), order='F')
x = 0.0; y= 0.0
print(C[:2].round(2))


