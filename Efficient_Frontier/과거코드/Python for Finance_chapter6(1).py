# 금융분야에서 빠질 수 없는 것이 시계열자료!
# 시계열 자료를 다루기위한 도구는 다름아닌 pandas!
# pandas는 만들어진 근본적 목적 자체가 그냥 시계열 자료임
# pandas에서 가장 중요한 클래스는 DataFrame 클래스 & Series 클래스 라고하니 알고 가자.

# CSV(Comma-separated value)파일은 금융 시계열 자료를 교환하기 위한 국제 표준이고
# pandas는 CSV 파일로부터 자료를 읽는 작업을 쉽게 만들어줌. pandas로 회귀분석까지 해볼것임


# 그러면 이제 들어가자 pandas의 기초! 우선 pandas는 numpy 위에서 구현되었다는 것을 알아야 해
# 따라서 두개를 모두 임포트하는 것으로 시작해야함

import numpy as np
import pandas as pd

# DataFrame 클래스는 인덱스와 라벨이 붙어있는 자료를 다루기 위해 설계되었고,
# SQL 데이터베이스 테이블이나, 스프레드시트 프로그램의 워크시트와 별반 다르지 않.....음....?
# 됐고, DataFrame 객체를 만들어보자

df = pd.DataFrame([10, 20, 30, 40], columns=['number'], index=['a', 'b', 'c', 'd'])
print(df)
# 보면 알 수 있듯이, 자료는 열로 구성되고, 열은 이름을 가질 수 있음
# 그리고 숫자, 문자, 시간 등의 다른 포맷으로 된 인덱스가 존재함

print(df.index)                     # 이렇게 인덱스만 숑! 뽑아낼 수도 있고
print(df.columns)                   # '열' 이름만 숑! 뽑아낼 수도 있음
print(df.loc['c'])                  # 쥬피터에서 ix['c']로 하는 걸 파이참에서는 loc를 쓰래. 결과는 똑같애, location이겠지
                                    # 암튼, index를 기반으로 뽑아낼 수 있고
print(df.loc[['a', 'b']])           # 복수개도 가능하고 (근데 왜 []에다가 다시 넣어야 하는거지?)
                                    # []에 넣지않으면 안되네, 대신 print(df.loc['a'], df.loc['b'])로 하면 되는 거 보니까
                                    # loc[]에는 하나만 들어갈 수 있고, 그렇지 않을 땐 []의 형태로 넣어야 하나봐
print(df.index[1:3])                # 위에서 df.index로 인덱스들을 숑! 뽑을 수 있었잖아,
                                    # 그거를 슬라이싱을 그냥 리스트처럼 [:]로하면 되는데, 인데스 모임을
print(df.loc[df.index[1:3]])        # df.loc[]에 넣어도 성립을 함!!!!!

print(df.sum())                     # df.sum()함수는 열을 잡고 싹 더해준대. 비트수도 나오네;;
print(df.apply(lambda x: x ** 2))   # apply는 함수를 집어넣으면, 그 함수에 숑 넣어서 나오는 값들로 다시 재구성을 해주는데
                                    # 여기에선 lambda로 그냥 직접 만들어서 넣어버렸네??? ㅇㅋㅇㅋ 이해갔다
print(df * 2)
print(df ** 3)                      # 그리고 이 DataFrame() 객체는 각 요소를 2배 한다던가, 각 요소를 거듭제곱 하는 작업을 할 수 있어

df['float'] = (1.5, 2.5, 3.5, 45)   # DataFrame 객체를 양쪽차원 확장할 수 있어. 객체이름['추가할콜런이름'] = (요, 소, 들, ...)
print(df)                           # 이러면 설정해놓은 index 'a', 'b', 'c', 'd'에 자동으로 대응하게 들어가 (갯수는 같아야 함)

print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------
# df = pd.DataFrame([10, 20, 30, 40], columns=['number'], index=['a', 'b', 'c', 'd'])
# print(df)                         # 위에서 했던 코드를 한 번 더 쓰면, 또 똑같은 콜런이 확장되는 것이 아니라, 그냥 초기화 됨

# 그러면 새로운 콜런을 추가하되, 인덱스를 내 마음대로 설정하는 방법이 뭐가있느냐
df['names'] = pd.DataFrame(['박근도', '강원구', '한환희', '정수건'], index = ['c', 'a', 'b', 'd'])
print(df)
# 객체이름['추가할 콜럼이름'] = dp.DataFrame([요, 소, 들, ...), index=[지, 정, 해])

# 인덱스를 쓰지 않으면? 어떻게 되느냐
# df['namess'] = pd.DataFrame(['박근도', '강원구', '한환희', '정수건'])
# print(df)                           # 이렇게 하면, NaN(Not a Number)로 뜨네, index는 default 옵션 없음!

# print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------
# 오른쪽으로 콜럼을 추가하는 거 말고, 밑으로 자료를 하나씩 추가하는 건 어떻게 하느냐?
df.append({'float': 5.75, 'number': 100, 'names': '이준호'}, ignore_index=True)
print(df)
                                    # 딕셔너리처럼, index를 키처럼, 요소들을 value처럼 넣어주며, ignore_index를 True로 놓아야 들어감
                                    # ignore_index를 빼니까 돌아가질 않아;;; 당연히, 인덱스를 설정을 안했으니까;;;
                                    # 그래서 잘 보면 설정해놨던 인덱스들 a,b,c,d 날아가고 0~4로 바뀌어 있음.

                                    # 이거는 df자체를 바꾸지는 않는 임시 객체를 생성하는 거라고 함. df 자체는 변하지 않음
                                    # 그래서 print()에서는 반영된 것이 나오지 않아. 근데 한 줄 실행을 해보면, 들어가 있음.
                                    # 거기에 0~4인덱싱으로 들어가 있음을 확인할 수 있음

# df = pd.DataFrame([10, 20, 30, 40], columns=['number'], index=['a', 'b', 'c', 'd'])
# 를 넣었을 때처럼, append에다가 pd.DataFrame으로 확장시켜버릴 수 있음.
# 하지만, 기존에 존재하는 콜럼에 하나씩 맞춰서 데이터를 넣는 거니까, 딕셔너리 형태로 쓰는거지!, index를 하나 추가하면서 말이야
df = df.append(pd.DataFrame({'number':101, 'float': 55, 'names': '조효진'}, index=['e',]))     # ','의 유무는 영향X 인듯
print(df)                           # df = 으로 쓰면서 넣으니깐, 근본적으로 변해있자네. 할당을 한 것이니까?
print("-" * 50, '구분좀')
# ----------------------------------------------------------------------------------------------------------------------
# df = df.join(pd.DataFrame([1, 4, 9, 16, 25], index=['a', 'b', 'c', 'd', 'y'], columns=['squares']))
                                    # join이란 함수로 오른쪽에 확장하는 것도 가능
                                    # 근데, 뜬금없이 등장한 y에는 넣질 못하니까 날아가고
                                    # 기존에 존재하던 'e'에는 대응하는게 없으니깐 NaN(Not a Number)로 넣어버림
# print(df)
# 아 근데, join의 문법을 보니깐, 새롭게 맨 처음 생성할 때 썼던 구문
# df = pd.DataFrame([10, 20, 30, 40], columns=['number'], index=['a', 'b', 'c', 'd'])
# 얘를 그냥 join으로 감싼것일 뿐이네? 그정도만 눈치채고 가자
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------
# 자 암튼 그래서 '기존 인덱스와, 추가되는 새로운 인덱스 값을 모두 보존하고 싶을 때는 join의 optional인 how=outer를 써야해
df = df.join(pd.DataFrame([1, 4, 9, 16, 25], index=['a', 'b', 'c', 'd', 'y'], columns=['squares']), how='outer')
print(df)                           # 보면 e에 대응하는 곳에 NaN넣고,
                                    # 'y'라는 인덱스 새롭게 만들어서 다른 애들은 NaN으로 넣지만, 25라는 인수를 놓치지 않고 추가하잖아
# how=outer를 좀 더 보자면,
# 존재하는 인덱스와 추가하는 인덱스의 합집합의 개념으로 모두 놓치지 않고 가는 거고
# how = inner는 교집합 / left는 존재하는 것을 기준 / right는 추가하는 객체를 기준! 뭐 이런게 있단다
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------

print(df['number'])                 # 호출 잘 되고요
# print(df['number', 'squares'])    # 두개를 부르고 싶을 땐, 이렇게 부르는 게 아니라, 대괄호[]로 묶어서 호출해야 합니다
print(df[['number', 'squares']])    # 이렇게 말이죠

print(df['number'].mean())                           # 불러낸 다음에 매써드를 쓸 수도 있습니다. DataFrame 객체이지 않습니까?
print(df[['number', 'squares', 'float']].mean())     # 복수도 되고요:)
print(df[['number', 'squares', 'float', 'names']].mean())     # 얼토당토 않는 건 걍 씹어버리네여

print(df[['number', 'squares', 'float']].std())      # 스탠다드데비에이션도 잡아줍니다요