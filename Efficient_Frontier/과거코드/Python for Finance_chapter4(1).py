# 수학에서 사용하는 행렬, 파이썬의 리스트로 그 기능을 구현할 수 있지만
# 리스트라는게 사실 딱 그 목적으로 만들어진게 아니잖아?
# 그래서 ""NumPy"" 모듈을 사용해야 함
# 그리고 특히 n차원 배열을 쉽고 효율적으로 고성능으로 다루기 위한 목적으로 만들거진 클래스가
# numpy.ndarray 클래스라고 함.

import numpy as np                      # 자 일단 import 해볼까
a = np.array([0, 0.5, 1.0, 1.5, 2.0])
print(type(a))                          # 타입은 'class 'numpy.ndarray''라고 뜸. 이 클래스 안에 여러가지 매써드가 있겠지

print(a[:2], 'a[:2]')                   # 뭐 일단 우선 인덱싱은 1차원 리스트랑 똑같고
print(a.sum(), 'sum')                   # 그 행 다 잡고 더하는거랑
print(a.std(), 'std')                   # 그 행 다 잡고 표준편차 구해주는 것도 있고
print(a.cumsum(), 'cumsum')             # 한개씩 열 늘려가면서 더하는 누적합계 기능도 있다
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------
print(2 * a, '2 * a')                   # 근데, ndarray의 특징은 벡터화된 형식의 수학 연산이 가능하다는 거래
print(2 ** a, '2 ** a')                 # 그냥 2에다 거듭제곱을 하는데, 요소들을 다 지수로 올리네
print(a ** 2, 'a ** 2')                 # 원소마다 지수에 2를 올릴 수도 있고
print(a * a, 'a_square')                # 이건 원소별로 곱하네, 뒤에꺼 transpose 안했는데?
print(np.sqrt(a), 'root_a')             # 모든 요소에 루트를 씌울수도
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------

b = np.array([a, a*2])
print(b, 'b')                                     # 이건 다차원 확장이다. array 원소로 리스트를 넣으면, 행으로 추가하네
print(b[0], '1행\n', b[1], '2행')                  # 2차원이 되면, 인덱싱으로 행씩 꺼내네
print(b[0, 0], '1행 2열 \n', b[1, 3], '2행 4열')    # [행, 렬] 번호로 행렬처럼 꺼낼 수 있다!
print(b.sum(), 'b.sum()')                         # 행렬 구분 없이 다 더해 버리네
print(b.sum(axis=0), 'b.sum(0)')                   # 0이라 입력하니까 (0번 축을 따라서) 열별로(아래로) 더한 값들,
print(b.sum(axis=1), 'b.sum(1)')                   # 1이라 입력하니까 (1번 축을 따라서) 행별로(오른쪽으로) 더한 값들 나오네
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------
#                                         위에서 했던 numpy.ndarray는 배열의 모든 원소를 미리 알고있어야 하는 점이 있지.....
#                                         근데 그러기가 싫을때가 있단 말이야.
c = np.zeros((2, 3))                 # 코드를 실행하면서 나중에 각 원소의 값을 지정하고 싶을 때는 zeros 혹은 ones를 만들어서
print(c, 'c')                        # 2행 3열의 행렬을 만들어내는거 보이지?
d = np.ones((2, 3, 4))               # 그럼 0으로 채워지거나, 1로만 채워진 걸 일단은 만들고 갈 수 있으니까!
print(d, 'd')                        # 이건 그런 2 x 3 x 4의 텐서를 만들어 내는 거겠네. 근데, 맨앞의 2가 행렬 갯수, 뒤에 3, 4가 행렬의 행과 열의 갯수인듯 하네
#                                         c = np.zeros(shape = , dtype= , order = ) 순으로 입력하라고 나타나는데,
"""
shape     : 정수 혹은 복수의 정수, 또는 원하는 shape를 가진 다른 numpy.ndarray 객체
dtype(옵션): numpy.dtype의 객체. 이 객체는 numpy 객체의 자료형을 표현하기 위한 NumPy만의 특별한 자료형이다.
order(옵션): 메모리에 원소를 저장하는 순서. C이면, C언어와 같이 행 기반으로 저장하고, F이면 포트란처럼 열 기반으로 저장

dtype 객체에 대하여:
t       : 비트필드         : t4(4비트)
b       : 불리언          : b(참 혹은 거짓)
i       : 정수            : i8(64비트)
u       : 부호 없는 정수   : u8(64비트)
f       : 부동소수점       : f8(64비트)
c       : 복소수 부동소수점 : c16(128비트)
O       : 객체            : O(객체에 대한 포인터)
S, a    : 문자열          : S24(24 글자)
U       : 유니코드 문자열   : U24(24 유니코드 글자)
V       : 기타            : V12(12바이트의 데이터 블럭)
"""
print("-" * 50, '구분좀')
# ---------------------------------------------------------------------------------------------------------------------
# 구조화 배열(structured array)은 뭐냐
dt = np.dtype([('name', 'S10'), ('Age', 'i4'),
               ('Height', 'f'), ('Children/Pets', 'i4', 2)])
s = np.array([('Smith', 45, 1.83, (0, 1)),
              ('Jones', 53, 1.72, (2, 2))], dtype=dt)
print(s, 's')
print(s[1]['Age'], '\n', 's[1]["Age"]')
# 여기는 내가 아직 무슨말인지 잘 이해가 안간다.....ㅠ.ㅠ 슬픔...
